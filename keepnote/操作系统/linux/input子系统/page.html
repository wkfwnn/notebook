<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Input子系统</title>
</head><body><div style="text-align: center"><img src="image.png" /></div><br/>
<br/>
input子系统框架图<br/>
1.input-core &nbsp;输入核心 <br/>
2.input-event-dev 输入事件驱动程序<br/>
3.input-driver &nbsp;输入设备驱动程序<br/>
如何理解：<br/>
输入事件是标准的，对于所有输入设备都应该是可以用的，要实现的是输入设备驱动程序。输入设备驱动程序可以选择合适的输入事件驱动程序，通过输入核心以及输入事件驱动程序，向用户层输入数据<br/>
通俗讲解：<br/>
输入核心：输入核心提供了注册设备驱动以及事件驱动的API，维护着事件驱动的链表以及设备驱动的链表<br/>
设备驱动 对应input_dev &nbsp;负责实际的设备数据读取，通过input core 将数据传递到事件驱动程序，上报给用户层<br/>
事件驱动，对应input_handler，负责创建设备节点，负责和应用层进行数据交互以及上报<br/>
设备驱动与事件驱动通过id_table进行match，match之后通过connect函数创建事件驱动，事件驱动负责创建设备节点，提供open，close 等文件操作函数包括/dev/input/eventX,或者mouse等，然后通过input_handle进行绑定。维护着client（上层用户）的链表，将数据传递给用户层以及每一个打开文件的client<br/>
<br/>
<br/>
相关的目录:drivers/input<br/>
相关的文件:input.c,evdev.c,input-polldev.c mousedev.c &nbsp;linux/include/input.h include/uapi/linux/input.h<br/>
相关的结构体：<br/>
<br/>
/**<br/>
&nbsp;* struct input_value - input value representation<br/>
&nbsp;* @type: type of value (EV_KEY, EV_ABS, etc)<br/>
&nbsp;* @code: the value code<br/>
&nbsp;* @value: the value<br/>
&nbsp;*/<br/>
struct input_value {<br/>
&#09;__u16 type;<br/>
&#09;__u16 code;<br/>
&#09;__s32 value;<br/>
};<br/>
注：对于所有的input设备，一般向上层应用输出的都是以上的结构体<br/>
/**<br/>
&nbsp;* struct input_dev - represents an input device<br/>
&nbsp;* @name: name of the device<br/>
&nbsp;* @phys: physical path to the device in the system hierarchy<br/>
&nbsp;* @uniq: unique identification code for the device (if device has it)<br/>
&nbsp;* @id: id of the device (struct input_id)<br/>
&nbsp;* @propbit: bitmap of device properties and quirks<br/>
&nbsp;* @evbit: bitmap of types of events supported by the device (EV_KEY,<br/>
&nbsp;*&#09;EV_REL, etc.)<br/>
&nbsp;* @keybit: bitmap of keys/buttons this device has<br/>
&nbsp;* @relbit: bitmap of relative axes for the device<br/>
&nbsp;* @absbit: bitmap of absolute axes for the device<br/>
&nbsp;* @mscbit: bitmap of miscellaneous events supported by the device<br/>
&nbsp;* @ledbit: bitmap of leds present on the device<br/>
&nbsp;* @sndbit: bitmap of sound effects supported by the device<br/>
&nbsp;* @ffbit: bitmap of force feedback effects supported by the device<br/>
&nbsp;* @swbit: bitmap of switches present on the device<br/>
&nbsp;* @hint_events_per_packet: average number of events generated by the<br/>
&nbsp;*&#09;device in a packet (between EV_SYN/SYN_REPORT events). Used by<br/>
&nbsp;*&#09;event handlers to estimate size of the buffer needed to hold<br/>
&nbsp;*&#09;events.<br/>
&nbsp;* @keycodemax: size of keycode table<br/>
&nbsp;* @keycodesize: size of elements in keycode table<br/>
&nbsp;* @keycode: map of scancodes to keycodes for this device<br/>
&nbsp;* @getkeycode: optional legacy method to retrieve current keymap.<br/>
&nbsp;* @setkeycode: optional method to alter current keymap, used to implement<br/>
&nbsp;*&#09;sparse keymaps. If not supplied default mechanism will be used.<br/>
&nbsp;*&#09;The method is being called while holding event_lock and thus must<br/>
&nbsp;*&#09;not sleep<br/>
&nbsp;* @ff: force feedback structure associated with the device if device<br/>
&nbsp;*&#09;supports force feedback effects<br/>
&nbsp;* @repeat_key: stores key code of the last key pressed; used to implement<br/>
&nbsp;*&#09;software autorepeat<br/>
&nbsp;* @timer: timer for software autorepeat<br/>
&nbsp;* @rep: current values for autorepeat parameters (delay, rate)<br/>
&nbsp;* @mt: pointer to multitouch state<br/>
&nbsp;* @absinfo: array of &amp;struct input_absinfo elements holding information<br/>
&nbsp;*&#09;about absolute axes (current value, min, max, flat, fuzz,<br/>
&nbsp;*&#09;resolution)<br/>
&nbsp;* @key: reflects current state of device's keys/buttons<br/>
&nbsp;* @led: reflects current state of device's LEDs<br/>
&nbsp;* @snd: reflects current state of sound effects<br/>
&nbsp;* @sw: reflects current state of device's switches<br/>
&nbsp;* @open: this method is called when the very first user calls<br/>
&nbsp;*&#09;input_open_device(). The driver must prepare the device<br/>
&nbsp;*&#09;to start generating events (start polling thread,<br/>
&nbsp;*&#09;request an IRQ, submit URB, etc.)<br/>
&nbsp;* @close: this method is called when the very last user calls<br/>
&nbsp;*&#09;input_close_device().<br/>
&nbsp;* @flush: purges the device. Most commonly used to get rid of force<br/>
&nbsp;*&#09;feedback effects loaded into the device when disconnecting<br/>
&nbsp;*&#09;from it<br/>
&nbsp;* @event: event handler for events sent _to_ the device, like EV_LED<br/>
&nbsp;*&#09;or EV_SND. The device is expected to carry out the requested<br/>
&nbsp;*&#09;action (turn on a LED, play sound, etc.) The call is protected<br/>
&nbsp;*&#09;by @event_lock and must not sleep<br/>
&nbsp;* @grab: input handle that currently has the device grabbed (via<br/>
&nbsp;*&#09;EVIOCGRAB ioctl). When a handle grabs a device it becomes sole<br/>
&nbsp;*&#09;recipient for all input events coming from the device<br/>
&nbsp;* @event_lock: this spinlock is is taken when input core receives<br/>
&nbsp;*&#09;and processes a new event for the device (in input_event()).<br/>
&nbsp;*&#09;Code that accesses and/or modifies parameters of a device<br/>
&nbsp;*&#09;(such as keymap or absmin, absmax, absfuzz, etc.) after device<br/>
&nbsp;*&#09;has been registered with input core must take this lock.<br/>
&nbsp;* @mutex: serializes calls to open(), close() and flush() methods<br/>
&nbsp;* @users: stores number of users (input handlers) that opened this<br/>
&nbsp;*&#09;device. It is used by input_open_device() and input_close_device()<br/>
&nbsp;*&#09;to make sure that dev-&gt;open() is only called when the first<br/>
&nbsp;*&#09;user opens device and dev-&gt;close() is called when the very<br/>
&nbsp;*&#09;last user closes the device<br/>
&nbsp;* @going_away: marks devices that are in a middle of unregistering and<br/>
&nbsp;*&#09;causes input_open_device*() fail with -ENODEV.<br/>
&nbsp;* @dev: driver model's view of this device<br/>
&nbsp;* @h_list: list of input handles associated with the device. When<br/>
&nbsp;*&#09;accessing the list dev-&gt;mutex must be held<br/>
&nbsp;* @node: used to place the device onto input_dev_list<br/>
&nbsp;* @num_vals: number of values queued in the current frame<br/>
&nbsp;* @max_vals: maximum number of values queued in a frame<br/>
&nbsp;* @vals: array of values queued in the current frame<br/>
&nbsp;* @devres_managed: indicates that devices is managed with devres framework<br/>
&nbsp;*&#09;and needs not be explicitly unregistered or freed.<br/>
&nbsp;*/<br/>
struct input_dev {<br/>
&#09;const char *name;<br/>
&#09;const char *phys;<br/>
&#09;const char *uniq;<br/>
&#09;struct input_id id;<br/>
<br/>
&#09;unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];<br/>
<br/>
&#09;unsigned long evbit[BITS_TO_LONGS(EV_CNT)];<br/>
&#09;unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];<br/>
&#09;unsigned long relbit[BITS_TO_LONGS(REL_CNT)];<br/>
&#09;unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];<br/>
&#09;unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];<br/>
&#09;unsigned long ledbit[BITS_TO_LONGS(LED_CNT)];<br/>
&#09;unsigned long sndbit[BITS_TO_LONGS(SND_CNT)];<br/>
&#09;unsigned long ffbit[BITS_TO_LONGS(FF_CNT)];<br/>
&#09;unsigned long swbit[BITS_TO_LONGS(SW_CNT)];<br/>
<br/>
&#09;unsigned int hint_events_per_packet;<br/>
<br/>
&#09;unsigned int keycodemax;<br/>
&#09;unsigned int keycodesize;<br/>
&#09;void *keycode;<br/>
<br/>
&#09;int (*setkeycode)(struct input_dev *dev,<br/>
&#09;&#09;&#09; &nbsp;const struct input_keymap_entry *ke,<br/>
&#09;&#09;&#09; &nbsp;unsigned int *old_keycode);<br/>
&#09;int (*getkeycode)(struct input_dev *dev,<br/>
&#09;&#09;&#09; &nbsp;struct input_keymap_entry *ke);<br/>
<br/>
&#09;struct ff_device *ff;<br/>
<br/>
&#09;unsigned int repeat_key;<br/>
&#09;struct timer_list timer;<br/>
<br/>
&#09;int rep[REP_CNT];<br/>
<br/>
&#09;struct input_mt *mt;<br/>
<br/>
&#09;struct input_absinfo *absinfo;<br/>
<br/>
&#09;unsigned long key[BITS_TO_LONGS(KEY_CNT)];<br/>
&#09;unsigned long led[BITS_TO_LONGS(LED_CNT)];<br/>
&#09;unsigned long snd[BITS_TO_LONGS(SND_CNT)];<br/>
&#09;unsigned long sw[BITS_TO_LONGS(SW_CNT)];<br/>
<br/>
&#09;int (*open)(struct input_dev *dev);<br/>
&#09;void (*close)(struct input_dev *dev);<br/>
&#09;int (*flush)(struct input_dev *dev, struct file *file);<br/>
&#09;int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);<br/>
<br/>
&#09;struct input_handle __rcu *grab;<br/>
<br/>
&#09;spinlock_t event_lock;<br/>
&#09;struct mutex mutex;<br/>
<br/>
&#09;unsigned int users;<br/>
&#09;bool going_away;<br/>
<br/>
&#09;struct device dev;<br/>
<br/>
&#09;struct list_head&#09;h_list;<br/>
&#09;struct list_head&#09;node;<br/>
<br/>
&#09;unsigned int num_vals;<br/>
&#09;unsigned int max_vals;<br/>
&#09;struct input_value *vals;<br/>
<br/>
&#09;bool devres_managed;<br/>
};<br/>
<br/>
以上结构体描述的是一个输入设备<br/>
<br/>
struct input_handler {<br/>
<br/>
&#09;void *private;<br/>
<br/>
&#09;void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value);<br/>
&#09;void (*events)(struct input_handle *handle,<br/>
&#09;&#09; &nbsp; &nbsp; &nbsp; const struct input_value *vals, unsigned int count);<br/>
&#09;bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value);<br/>
&#09;bool (*match)(struct input_handler *handler, struct input_dev *dev);<br/>
&#09;int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id);<br/>
&#09;void (*disconnect)(struct input_handle *handle);<br/>
&#09;void (*start)(struct input_handle *handle);<br/>
<br/>
&#09;bool legacy_minors;<br/>
&#09;int minor;<br/>
&#09;const char *name;<br/>
<br/>
&#09;const struct input_device_id *id_table;<br/>
<br/>
&#09;struct list_head&#09;h_list;<br/>
&#09;struct list_head&#09;node;<br/>
};<br/>
以上的结构体描述的是事件驱动程序<br/>
<br/>
struct input_handle {<br/>
<br/>
&#09;void *private;<br/>
<br/>
&#09;int open;<br/>
&#09;const char *name;<br/>
<br/>
&#09;struct input_dev *dev;<br/>
&#09;struct input_handler *handler;<br/>
<br/>
&#09;struct list_head&#09;d_node;<br/>
&#09;struct list_head&#09;h_node;<br/>
};<br/>
以上的结构体是将输入设备与输入的事件绑定到一起<br/>
<br/>
相关的API<br/>
输入设备的驱动程序：<br/>
int __must_check input_register_device(struct input_dev *);<br/>
void input_unregister_device(struct input_dev *);<br/>
void input_reset_device(struct input_dev *);<br/>
<br/>
输入事件的驱动程序:<br/>
int __must_check input_register_handler(struct input_handler *);<br/>
void input_unregister_handler(struct input_handler *);<br/>
<br/>
设备驱动程序report值:<br/>
<br/>
input_report_key/input_report_rel/input_report_abs/input_report_switch/<b>input_sync</b><br/>
也可以调用:<br/>
void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);<br/>
void input_inject_event(struct input_handle *handle, unsigned int type, unsigned int code, int value);<br/>
<br/>
<br/>
<br/>
<br/>
</body></html>